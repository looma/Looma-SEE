// src/lib/use-questions.ts
"use client"

import { useState, useEffect } from "react"

export interface GroupAQuestion {
id: string
nepali: string
english: string
options: { id: string; nepali: string; english: string }[]
correctAnswer: string
marks: number
}

export interface FreeResponseQuestion {
id: string
nepali: string
english: string
marks: number
}

interface QuestionsData {
groupA: GroupAQuestion[]
groupB: FreeResponseQuestion[]
groupC: FreeResponseQuestion[]
groupD: FreeResponseQuestion[]
}

export function useQuestions(testId = "see_2080_science") {
const [questions, setQuestions] = useState<QuestionsData | null>(null)
const [loading, setLoading] = useState(true)
const [error, setError] = useState<string | null>(null)

useEffect(() => {
  async function fetchQuestions() {
    try {
      setLoading(true)
      const response = await fetch(`/api/questions/${testId}`)
      if (!response.ok) {
        const msg = await response.text()
        throw new Error(msg || "Failed to fetch questions")
      }
      const data = await response.json()
      // API already returns { questions: { groupA, groupB, groupC, groupD } }
      setQuestions(data.questions)
    } catch (err) {
      setError(err instanceof Error ? err.message : "Unknown error")
      console.error("Error fetching questions:", err)
    } finally {
      setLoading(false)
    }
  }

  fetchQuestions()
}, [testId])

return { questions, loading, error }
}

// src/lib/mongodb.ts
import { MongoClient, type Db } from "mongodb"

const uri = process.env.MONGODB_URI || "mongodb://127.0.0.1:27017/see_exam_system"

type GlobalWithMongo = typeof globalThis & {
_mongoClient?: MongoClient
_mongoDb?: Db
}

const g = global as GlobalWithMongo

export async function connectToDatabase() {
if (g._mongoClient && g._mongoDb) {
  return { client: g._mongoClient, db: g._mongoDb }
}

const client = new MongoClient(uri)
await client.connect()
const dbNameFromUri = (() => {
  try {
    const path = new URL(uri).pathname
    return path?.replace("/", "") || "see_exam_system"
  } catch {
    return "see_exam_system"
  }
})()
const db = client.db(dbNameFromUri)

g._mongoClient = client
g._mongoDb = db

return { client, db }
}

// src/app/api/questions/[testId]/route.ts
import { type NextRequest, NextResponse } from "next/server"
import { connectToDatabase } from "@/lib/mongodb"

export async function GET(request: NextRequest, { params }: { params: { testId: string } }) {
try {
  const { testId } = params

  // Placeholder tests with no data yet
  const placeholderTests = ["see_2079_science", "see_2078_science", "see_2080_math", "see_2080_english"]
  if (placeholderTests.includes(testId)) {
    return NextResponse.json({
      testId,
      questions: { groupA: [], groupB: [], groupC: [], groupD: [] },
    })
  }

  const { db } = await connectToDatabase()
  const questionsCollection = db.collection("questions")
  const questionsDoc = await questionsCollection.findOne({ testId })

  if (!questionsDoc) {
    return NextResponse.json({ error: `Test not found: ${testId}` }, { status: 404 })
  }

  const transformedQuestions = {
    groupA: (questionsDoc.questions.groupA || []).map((q: any) => ({
      id: q.id,
      nepali: q.questionNepali,
      english: q.questionEnglish,
      options: q.options || [],
      correctAnswer: q.correctAnswer,
      marks: q.marks,
    })),
    groupB: (questionsDoc.questions.groupB || []).map((q: any) => ({
      id: q.id,
      nepali: q.questionNepali,
      english: q.questionEnglish,
      marks: q.marks,
    })),
    groupC: (questionsDoc.questions.groupC || []).map((q: any) => ({
      id: q.id,
      nepali: q.questionNepali,
      english: q.questionEnglish,
      marks: q.marks,
    })),
    groupD: (questionsDoc.questions.groupD || []).map((q: any) => ({
      id: q.id,
      nepali: q.questionNepali,
      english: q.questionEnglish,
      marks: q.marks,
    })),
  }

  return NextResponse.json({ testId, questions: transformedQuestions })
} catch (error) {
  console.error("Error fetching questions:", error)
  return NextResponse.json({ error: "Failed to fetch questions" }, { status: 500 })
}
}

// src/app/api/grade/route.ts
import { openai } from "@ai-sdk/openai"
import { generateObject } from "ai"
import { z } from "zod"

export const maxDuration = 30

export async function POST(req: Request) {
try {
  const { question, answer, marks } = await req.json()
  if (!question || typeof answer !== "string" || typeof marks !== "number") {
    return new Response(JSON.stringify({ error: "Missing required fields" }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    })
  }

  if (!process.env.OPENAI_API_KEY) {
    return new Response(
      JSON.stringify({ error: "AI is unavailable (missing OPENAI_API_KEY). Please try again later.", code: "AI_UNAVAILABLE" }),
      { status: 503, headers: { "Content-Type": "application/json" } },
    )
  }

  const { object } = await generateObject({
    model: openai("gpt-4o"), // AI SDK OpenAI integration [^2]
    schema: z.object({
      score: z.number().int().min(0).max(marks),
      feedback: z.string(),
    }),
    system:
      "You are an expert SEE Science examiner. Be concise, specific, and fair. Keep feedback to 1-3 sentences.",
    prompt: `
        Grade the student's answer.

        Rules:
        - Score: integer between 0 and ${marks}
        - Feedback: concise, specific, constructive
        - The answer may be in Nepali or English.

        Question (${marks} marks): ${question}
        Student answer: ${answer}
        `.trim(),
  })

  return new Response(JSON.stringify(object), { headers: { "Content-Type": "application/json" } })
} catch (error) {
  console.error("AI grading error:", error)
  return new Response(JSON.stringify({ error: "AI grading failed. Please retry.", code: "AI_ERROR" }), {
    status: 502,
    headers: { "Content-Type": "application/json" },
  })
}
}

// scripts/import-test-json.mjs
// Usage:
//   node scripts/import-test-json.mjs --file ./data/see-2081.json
//   node scripts/import-test-json.mjs --url https://example.com/see-2081.json
//
// Env:
//   MONGODB_URI (default: mongodb://127.0.0.1:27017/see_exam_system)

import { MongoClient } from "mongodb"
import fs from "node:fs/promises"

const uri = process.env.MONGODB_URI || "mongodb://127.0.0.1:27017/see_exam_system"

function parseArgs() {
const argv = process.argv.slice(2)
const out = {}
for (let i = 0; i < argv.length; i++) {
  const token = argv[i]
  if (token === "--file" || token === "-f") {
    const next = argv[i + 1]
    if (next && !next.startsWith("--") && !next.startsWith("-")) {
      out.file = next
      i++
    } else {
      out.file = true
    }
    continue
  }
  if (token.startsWith("--file=")) {
    out.file = token.slice("--file=".length)
    continue
  }
  if (token === "--url" || token === "-u") {
    const next = argv[i + 1]
    if (next && !next.startsWith("--") && !next.startsWith("-")) {
      out.url = next
      i++
    } else {
      out.url = true
    }
    continue
  }
  if (token.startsWith("--url=")) {
    out.url = token.slice("--url=".length)
    continue
  }
  if (token === "--verbose" || token === "-v") {
    out.verbose = true
    continue
  }
}
return out
}

async function readInput({ file, url }) {
if (file === true) {
  console.warn("⚠️  --file was provided without a path. Defaulting to ./data/see-2081.json")
  file = "./data/see-2081.json"
}
if (url === true) {
  throw new Error("You passed --url without a value. Use: --url https://example.com/file.json")
}
if (typeof file === "string" && file.length > 0) {
  const raw = await (await import("node:fs/promises")).readFile(file, "utf8")
  return JSON.parse(raw)
}
if (typeof url === "string" && url.length > 0) {
  const res = await fetch(url)
  if (!res.ok) throw new Error(`Failed to fetch URL: ${res.status} ${res.statusText}`)
  return await res.json()
}
throw new Error("Provide --file <path> or --file=<path> or --url <https://...>")
}

function normalizeExtendedJSON(value) {
if (Array.isArray(value)) return value.map(normalizeExtendedJSON)
if (value && typeof value === "object") {
  if (Object.keys(value).length === 1 && "$date" in value) {
    const d = value["$date"]
    return new Date(d)
  }
  if (Object.keys(value).length === 1 && "$oid" in value) {
    return String(value["$oid"])
  }
  const obj = {}
  for (const [k, v] of Object.entries(value)) obj[k] = normalizeExtendedJSON(v)
  return obj
}
return value
}

async function main() {
const args = parseArgs()
const input = await readInput({ file: args.file, url: args.url })
if (!Array.isArray(input)) throw new Error("Expected the JSON to be an array of documents.")

const docs = input.map(normalizeExtendedJSON)
const practiceDoc = docs.find((d) => d.title && d.subject && typeof d._id === "string")
const questionsDoc = docs.find((d) => d.testId && d.questions)

if (!practiceDoc) throw new Error("Missing practice_tests document with string _id.")
const testId = practiceDoc._id

if (!questionsDoc) throw new Error("Missing questions document with testId and questions.")
if (questionsDoc.testId !== testId) {
  console.warn(`questions.testId (${questionsDoc.testId}) != practice_tests._id (${testId}). Normalizing.`)
  questionsDoc.testId = testId
}
if ("_id" in questionsDoc && typeof questionsDoc._id !== "string") delete questionsDoc._id

const client = new MongoClient(uri)
try {
  console.log("Connecting to", uri)
  await client.connect()
  let dbName = "see_exam_system"
  try {
    const u = new URL(uri)
    dbName = u.pathname.replace("/", "") || "see_exam_system"
  } catch {}
  const db = client.db(dbName)

  const practiceTests = db.collection("practice_tests")
  const questions = db.collection("questions")

  const {
    _id: practiceId,
    createdAt: incomingCreatedAt,
    updatedAt: incomingUpdatedAt,
    ...practiceRest // critical: exclude createdAt/updatedAt from $set to avoid conflicts
  } = practiceDoc

  await practiceTests.updateOne(
    { _id: practiceId },
    {
      $set: { ...practiceRest, updatedAt: new Date() },
      $setOnInsert: {
        _id: practiceId,
        createdAt: incomingCreatedAt instanceof Date ? incomingCreatedAt : new Date(),
      },
    },
    { upsert: true },
  )
  console.log(`✅ Upserted practice test: ${practiceId}`)

  await questions.updateOne(
    { testId },
    { $set: { testId, questions: questionsDoc.questions } },
    { upsert: true },
  )
  console.log(`✅ Upserted questions for testId: ${testId}`)
  console.log("🎉 Import finished")
} finally {
  await client.close()
}
}

// src/app/globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
--foreground-rgb: 0, 0, 0;
--background-start-rgb: 214, 219, 220;
--background-end-rgb: 255, 255, 255;
}

@media (prefers-color-scheme: dark) {
:root {
  --foreground-rgb: 255, 255, 255;
  --background-start-rgb: 0, 0, 0;
  --background-end-rgb: 0, 0, 0;
}
}

body {
color: rgb(var(--foreground-rgb));
background: linear-gradient(to bottom,
    transparent,
    rgb(var(--background-end-rgb))) rgb(var(--background-start-rgb));
}

/* Section progress color helpers */
.progress-yellow { background-color: rgb(254 249 195 / 0.6); } /* track */
.progress-yellow > div { background-color: rgb(234 179 8) !important; } /* indicator: amber-500 */

.progress-green { background-color: rgb(220 252 231 / 0.6); }
.progress-green > div { background-color: rgb(22 163 74) !important; } /* green-600 */

.progress-purple { background-color: rgb(243 232 255 / 0.6); }
.progress-purple > div { background-color: rgb(124 58 237) !important; } /* purple-600 */

.progress-orange { background-color: rgb(255 237 213 / 0.6); }
.progress-orange > div { background-color: rgb(249 115 22) !important; } /* orange-500 */

.progress-amber { background-color: rgb(254 243 199 / 0.6); }
.progress-amber > div { background-color: rgb(217 119 6) !important; } /* amber-600 */

// src/components/group-a.tsx
import { Card, CardContent, CardHeader } from "@/components/ui/card"
import { Progress } from "@/components/ui/progress"
import { useExamContext } from "@/contexts/exam-context"
import Question from "./question"

export default function GroupA() {
const { questions, answers, setAnswer, progress } = useExamContext()

return (
  <Card>
    <CardHeader className="bg-gradient-to-r from-yellow-500 to-amber-500 text-white py-5">
      <div className="flex items-center justify-between">
        <h2 className="text-lg font-semibold">Group 'A' - Multiple Choice Questions</h2>
        <h2 className="text-lg font-semibold">समूह 'क' - बहुउत्तर प्रश्नहरू</h2>
      </div>
    </CardHeader>
    <CardContent className="grid gap-4">
      {questions?.groupA?.map((question, index) => (
        <Question
          key={question.id}
          question={question}
          answer={answers[question.id]}
          setAnswer={setAnswer}
          index={index}
        />
      ))}
      <Progress value={progress} className="mt-3 progress-yellow" />
    </CardContent>
  </Card>
)
}

// src/components/free-response-group.tsx
import { Card, CardContent, CardHeader } from "@/components/ui/card"
import { Progress } from "@/components/ui/progress"
import { useExamContext } from "@/contexts/exam-context"
import Question from "./question"
import Textarea from "./textarea"

interface Props {
group: "B" | "C" | "D"
}

export default function FreeResponseGroup({ group }: Props) {
const { questions, answers, setAnswer, progress } = useExamContext()

const groupDetails = {
  B: {
    title: "Group 'B' - Very Short Answers",
    titleNepali: "समूह 'ख' - अति छोटो उत्तर",
    totalMarks: 9,
    color: "from-green-500 to-green-600",
    bgColor: "bg-green-50/50",
    borderColor: "border-green-200",
    progressClass: "progress-green",
  },
  C: {
    title: "Group 'C' - Short Answers",
    titleNepali: "समूह 'ग' - छोटो उत्तर",
    totalMarks: 28,
    color: "from-purple-500 to-purple-600",
    bgColor: "bg-purple-50/50",
    borderColor: "border-purple-200",
    progressClass: "progress-purple",
  },
  D: {
    title: "Group 'D' - Long Answers",
    titleNepali: "समूह 'घ' - लामो उत्तर",
    totalMarks: 28,
    color: "from-orange-500 to-orange-600",
    bgColor: "bg-orange-50/50",
    borderColor: "border-orange-200",
    progressClass: "progress-orange",
  },
}

const details = groupDetails[group]

return (
  <Card>
    <CardHeader className={`bg-gradient-to-r ${details.color} text-white py-5`}>
      <div className="flex items-center justify-between">
        <h2 className="text-lg font-semibold">{details.title}</h2>
        <h2 className="text-lg font-semibold">{details.titleNepali}</h2>
      </div>
    </CardHeader>
    <CardContent className="grid gap-4">
      {questions?.[`group${group}`]?.map((question, index) => (
        <div key={question.id} className={`rounded-lg border ${details.borderColor} bg-white p-4`}>
          <Question question={question} index={index} />
          <Textarea
            id={question.id}
            question={question}
            answer={answers[question.id] || ""}
            setAnswer={setAnswer}
          />
        </div>
      ))}
      <Progress value={progress} className={`mt-3 ${details.progressClass}`} />
    </CardContent>
  </Card>
)
}

// src/components/results-card.tsx
import { Badge } from "@/components/ui/badge"
import { Card, CardContent, CardHeader } from "@/components/ui/card"
import { useExamContext } from "@/contexts/exam-context"

export default function ResultsCard() {
const { questions, answers } = useExamContext()

const renderMultipleChoiceSection = () => {
  if (!questions?.groupA) return null

  const correctAnswers = questions.groupA.reduce((acc, question) => {
    return { ...acc, [question.id]: question.correctAnswer }
  }, {})

  const score = questions.groupA.reduce((acc, question) => {
    return answers[question.id] === correctAnswers[question.id] ? acc + question.marks : acc
  }, 0)

  const totalMarks = questions.groupA.reduce((acc, question) => acc + question.marks, 0)

  return (
    <div className="flex items-center justify-between p-4 rounded-lg bg-blue-50 mb-4 min-h-[56px]">
      <div>
        <h3 className="text-lg font-semibold leading-tight">Multiple Choice</h3>
        <p className="text-sm text-gray-500 leading-tight">Group A</p>
      </div>
      <div>
        <Badge variant="secondary">
          {score} / {totalMarks}
        </Badge>
      </div>
    </div>
  )
}

const section = (group: "B" | "C" | "D", color: string) => {
  if (!questions?.[`group${group}`]) return null

  const totalMarks = questions[`group${group}`].reduce((acc, question) => acc + question.marks, 0)

  return (
    <div className={`flex items-center justify-between p-4 rounded-lg ${color} mb-4 min-h-[56px]`}>
      <div>
        <h3 className="text-lg font-semibold leading-tight">Free Response</h3>
        <p className="text-sm text-gray-500 leading-tight">Group {group}</p>
      </div>
      <div>
        <Badge variant="secondary"> / {totalMarks}</Badge>
      </div>
    </div>
  )
}

return (
  <Card>
    <CardHeader>
      <h2 className="text-lg font-semibold">Results</h2>
      <p className="text-sm text-gray-500">Your score</p>
    </CardHeader>
    <CardContent>
      {renderMultipleChoiceSection()}
      {section("B", "bg-green-50")}
      {section("C", "bg-purple-50")}
      {section("D", "bg-orange-50")}
    </CardContent>
  </Card>
)
}

// src/components/exam-tabs.tsx
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { useExamContext } from "@/contexts/exam-context"
import GroupA from "./group-a"
import FreeResponseGroup from "./free-response-group"
import ResultsCard from "./results-card"
import { Progress } from "@/components/ui/progress"
import { useState } from "react"

export default function ExamTabs() {
const { overallProgress } = useExamContext()
const [gradingError, setGradingError] = useState<string | null>(null)

return (
  <Tabs defaultValue="groupA" className="w-full">
    <TabsList>
      <TabsTrigger value="groupA">Group A</TabsTrigger>
      <TabsTrigger value="groupB">Group B</TabsTrigger>
      <TabsTrigger value="groupC">Group C</TabsTrigger>
      <TabsTrigger value="groupD">Group D</TabsTrigger>
      <TabsTrigger value="results">Results</TabsTrigger>
    </TabsList>
    <Progress value={overallProgress} className="h-3 mb-2 progress-amber" />
    <TabsContent value="groupA">
      <GroupA />
    </TabsContent>
    <TabsContent value="groupB">
      <FreeResponseGroup group="B" />
    </TabsContent>
    <TabsContent value="groupC">
      <FreeResponseGroup group="C" />
    </TabsContent>
    <TabsContent value="groupD">
      <FreeResponseGroup group="D" />
    </TabsContent>
    <TabsContent value="results">
      <ResultsCard />
    </TabsContent>
  </Tabs>
)
}
